import { readdir, readFile, writeFile, mkdir } from "fs/promises";
import { extname, basename, join } from "path";
import { createCanvas } from "canvas";

interface TextFile {
  filename: string;
  content: string;
  lines: string[];
}

// Constants optimized for thermal printer (384px width)
const PRINTER_WIDTH = 384;
const PADDING = 8;
const FONT_FAMILY = "Liberation Mono";
const LINE_WIDTH = 35; // Must match generate-markdown.ts LINE_WIDTH

// Monospace font width ratio: character width is typically 60-65% of font size
// For Liberation Mono at rendering size, we use 0.625 (5/8) as a reliable ratio
const CHAR_WIDTH_TO_FONT_RATIO = 0.625;

// Calculate usable width and derive font size
const USABLE_WIDTH = PRINTER_WIDTH - PADDING * 2;
const DESIRED_CHAR_WIDTH = USABLE_WIDTH / LINE_WIDTH;
const FONT_SIZE_PX = Math.round(DESIRED_CHAR_WIDTH / CHAR_WIDTH_TO_FONT_RATIO);
const FONT_SIZE = `${FONT_SIZE_PX}px`;

// Line height is typically 1.3x the font size for comfortable spacing
const CHAR_HEIGHT = Math.ceil(FONT_SIZE_PX * 1.3);

console.log(`Calculated font size: ${FONT_SIZE} (width: ${DESIRED_CHAR_WIDTH.toFixed(2)}px per char)`);

// Calculate actual character width for validation
const ACTUAL_CHAR_WIDTH = (USABLE_WIDTH / LINE_WIDTH);
const MAX_CHARS_PER_LINE = LINE_WIDTH;

function renderTextToCanvas(lines: string[]): { buffer: Buffer; height: number } {
  // Calculate canvas dimensions
  const height = PADDING * 2 + lines.length * CHAR_HEIGHT;
  const canvas = createCanvas(PRINTER_WIDTH, height);
  const ctx = canvas.getContext("2d");

  // White background
  ctx.fillStyle = "#FFFFFF";
  ctx.fillRect(0, 0, PRINTER_WIDTH, height);

  // Black text
  ctx.fillStyle = "#000000";
  ctx.font = `${FONT_SIZE} ${FONT_FAMILY}`;
  ctx.textBaseline = "top";

  // Render each line
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const y = PADDING + i * CHAR_HEIGHT;
    ctx.fillText(line, PADDING, y);
  }

  // Get image data and apply 1-bit threshold
  const imageData = ctx.getImageData(0, 0, PRINTER_WIDTH, height);
  const data = imageData.data;

  // Apply threshold to convert to pure black and white (1-bit)
  // Any pixel with luminance > 127.5 becomes white (255), else black (0)
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];

    // Calculate luminance using standard formula
    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

    // Threshold: > 127.5 = white (255), else black (0)
    const bw = luminance > 127.5 ? 255 : 0;
    data[i] = bw;
    data[i + 1] = bw;
    data[i + 2] = bw;
    data[i + 3] = 255; // Alpha = opaque
  }

  // Create a new canvas with the thresholded image data
  const bwCanvas = createCanvas(PRINTER_WIDTH, height);
  const bwCtx = bwCanvas.getContext("2d");
  bwCtx.putImageData(imageData, 0, 0);

  // Save as PNG (canvas outputs 8-bit, but our image is pure B&W)
  const buffer = bwCanvas.toBuffer("image/png");

  return { buffer, height };
}

async function loadAndParseTextFile(
  filePath: string
): Promise<TextFile> {
  const content = await readFile(filePath, "utf-8");
  const lines = content.split("\n").map((line) => {
    // Ensure each line is properly padded to match exact monospace layout
    return line.length > 0 ? line : "";
  });

  return {
    filename: basename(filePath),
    content,
    lines,
  };
}

async function main() {
  const inputDir = "./cheatsheets";
  const outputDir = "./cheatsheets";

  // Create output directory
  await mkdir(outputDir, { recursive: true });

  // Find all .txt files (generated by generate-markdown.ts)
  const files = await readdir(inputDir);
  const txtFiles = files.filter((f) => extname(f) === ".txt");

  console.log(`Found ${txtFiles.length} txt file(s)`);

  for (const file of txtFiles) {
    const txtPath = join(inputDir, file);
    const baseName = basename(file, ".txt");

    try {
      const textFile = await loadAndParseTextFile(txtPath);
      const { buffer, height } = renderTextToCanvas(textFile.lines);

      const outputPath = join(outputDir, `${baseName}.png`);
      await writeFile(outputPath, buffer);
      console.log(
        `✓ Generated: ${outputPath} (${PRINTER_WIDTH}x${height}px)`
      );
    } catch (error) {
      console.error(`✗ Error processing ${file}:`, error);
    }
  }
}

main();
